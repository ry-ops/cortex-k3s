/**
 * Transcript Extractor
 * Extracts transcripts from YouTube videos using Python backend
 */

import { execFile } from 'child_process';
import { promisify } from 'util';
import { config } from '../config.js';

const execFileAsync = promisify(execFile);

export class TranscriptExtractor {
  constructor() {
    this.config = config.extraction;
  }

  /**
   * Extract transcript from a YouTube video
   * @param {string} videoId
   * @param {Object} options - Extraction options
   * @returns {Promise<Object>}
   */
  async extract(videoId, options = {}) {
    const {
      language = this.config.preferredLanguages[0],
      includeTimestamps = this.config.includeTimestamps
    } = options;

    console.log(`[TranscriptExtractor] Extracting transcript for video: ${videoId}`);

    let lastError = null;

    // Try preferred languages in order
    for (const lang of this.config.preferredLanguages) {
      try {
        const transcript = await this.extractWithRetry(videoId, lang);

        if (transcript && transcript.length > 0) {
          console.log(`[TranscriptExtractor] Successfully extracted transcript (${lang})`);

          return {
            videoId,
            language: lang,
            segments: transcript.map(segment => ({
              text: segment.text,
              offset: segment.offset,
              duration: segment.duration,
              timestamp: this.formatTimestamp(segment.offset)
            })),
            rawText: transcript.map(s => s.text).join(' '),
            wordCount: this.countWords(transcript),
            hasTimestamps: includeTimestamps,
            extractedAt: new Date().toISOString()
          };
        }
      } catch (error) {
        lastError = error;
        console.log(`[TranscriptExtractor] Failed for language ${lang}: ${error.message}`);
      }
    }

    // If all languages failed, try without language specification
    if (this.config.fallbackToAutoGenerated) {
      try {
        const transcript = await this.extractWithRetry(videoId);

        if (transcript && transcript.length > 0) {
          console.log(`[TranscriptExtractor] Successfully extracted auto-generated transcript`);

          return {
            videoId,
            language: 'auto',
            segments: transcript.map(segment => ({
              text: segment.text,
              offset: segment.offset,
              duration: segment.duration,
              timestamp: this.formatTimestamp(segment.offset)
            })),
            rawText: transcript.map(s => s.text).join(' '),
            wordCount: this.countWords(transcript),
            hasTimestamps: includeTimestamps,
            extractedAt: new Date().toISOString()
          };
        }
      } catch (error) {
        lastError = error;
      }
    }

    throw new Error(`Failed to extract transcript: ${lastError?.message || 'Unknown error'}`);
  }

  /**
   * Extract with retry logic using Python script
   * @private
   */
  async extractWithRetry(videoId, language = null) {
    let lastError = null;
    const lang = language || 'en';

    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        const { stdout, stderr } = await execFileAsync('python3', [
          '/app/extract_transcript.py',
          videoId,
          lang
        ], {
          timeout: 30000
        });

        if (stderr && stderr.trim()) {
          console.log(`[TranscriptExtractor] Python stderr: ${stderr}`);
        }

        const result = JSON.parse(stdout);

        if (!result.success) {
          throw new Error(result.error || 'Unknown error from Python extractor');
        }

        if (!result.segments || result.segments.length === 0) {
          throw new Error('Transcript has no segments');
        }

        console.log(`[TranscriptExtractor] Successfully extracted ${result.segments.length} segments`);
        return result.segments;

      } catch (error) {
        lastError = error;
        console.log(`[TranscriptExtractor] Attempt ${attempt}/${this.config.maxRetries} failed: ${error.message}`);

        if (attempt < this.config.maxRetries) {
          await this.sleep(this.config.retryDelay * attempt);
        }
      }
    }

    throw lastError;
  }

  /**
   * Format timestamp from milliseconds to HH:MM:SS
   * @private
   */
  formatTimestamp(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000);
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }

  /**
   * Count words in transcript
   * @private
   */
  countWords(transcript) {
    const text = transcript.map(s => s.text).join(' ');
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  /**
   * Sleep utility
   * @private
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Get available languages for a video
   * @param {string} videoId
   * @returns {Promise<Array<string>>}
   */
  async getAvailableLanguages(videoId) {
    try {
      // This is a limitation of the library - we'd need to use yt-dlp for this
      // For now, we'll try the preferred languages
      return this.config.preferredLanguages;
    } catch (error) {
      console.error(`[TranscriptExtractor] Failed to get languages: ${error.message}`);
      return [];
    }
  }
}

export default TranscriptExtractor;
